<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js FBX Outline Viewer</title>
    <style>
        body { margin: 0; background-color: #333; color: #fff; font-family: sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            z-index: 100;
        }
        h3 { margin-top: 0; }
        .input-group { margin-bottom: 10px; }
        label { display: block; margin-bottom: 5px; }
        #animation-buttons { margin-top: 15px; }
        button {
            margin-right: 5px;
            margin-bottom: 5px;
            padding: 8px 12px;
            border: none;
            background-color: #555;
            color: white;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover { background-color: #777; }
        button.active { background-color: #007bff; }
        .checkbox-group {
            margin-top: 15px;
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h3>FBX Asset Loader</h3>
        <div class="input-group">
            <label for="character-input">1. Load Character (FBX)</label>
            <input type="file" id="character-input" accept=".fbx">
        </div>
        <div class="input-group">
            <label for="animations-input">2. Load Animations (FBX)</label>
            <input type="file" id="animations-input" accept=".fbx" multiple>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="toon-shader-checkbox">
            <label for="toon-shader-checkbox" style="margin-left: 5px; margin-bottom: 0;">Enable Toon Shader & Outline</label>
        </div>
        <div id="animation-buttons">
            <p>Animations:</p>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';

        // ## 1. Scene Setup ##
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x6f9ceb);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 3, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        const effect = new OutlineEffect(renderer);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);

        // ## 2. Lighting ##
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 3);
        dirLight.position.set(10, 10, 5);
        scene.add(dirLight);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ color: 0x4a8445, depthWrite: false })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        
        // ## 3. Toon Shader Setup ##
        function createGradientMap() {
            const size = 3;
            const data = new Uint8Array(size * 4);
            const colors = [new THREE.Color(0x333333), new THREE.Color(0x888888), new THREE.Color(0xFFFFFF)];
            
            colors.forEach((color, i) => {
                data[i * 4] = color.r * 255;
                data[i * 4 + 1] = color.g * 255;
                data[i * 4 + 2] = color.b * 255;
                data[i * 4 + 3] = 255;
            });

            const gradientMap = new THREE.DataTexture(data, size, 1, THREE.RGBAFormat);
            gradientMap.needsUpdate = true;
            return gradientMap;
        }
        const toonGradientMap = createGradientMap();
        toonGradientMap.minFilter = THREE.NearestFilter;
        toonGradientMap.magFilter = THREE.NearestFilter;


        // ## 4. Animation and Model Handling ##
        const clock = new THREE.Clock();
        let mixer;
        let model;
        const animations = {}; 
        let activeAction;
        let isToonShader = false;

        const fbxLoader = new FBXLoader();

        // ## Event Listeners for File Inputs ##
        const charInput = document.getElementById('character-input');
        charInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            loadCharacter(url);
        });

        const animInput = document.getElementById('animations-input');
        animInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (!model) {
                alert("Please load a character model first!");
                return;
            }
            loadAnimations(files);
        });
        
        const toonCheckbox = document.getElementById('toon-shader-checkbox');
        toonCheckbox.addEventListener('change', (event) => {
            isToonShader = event.target.checked;
            setShader(model, isToonShader);
        });

        function loadCharacter(url) {
            if (model) scene.remove(model);
            if (mixer) {
                mixer.stopAllAction();
                mixer = null;
            }
            // THE FIX: The crashing line 'effect.selection.clear()' is removed.
            Object.keys(animations).forEach(key => delete animations[key]);

            fbxLoader.load(url, (object) => {
                model = object;
                model.scale.setScalar(0.01); 
                
                prepareModelForToonShader(model);
                setShader(model, isToonShader);
                
                scene.add(model);

                mixer = new THREE.AnimationMixer(model);
                if (object.animations.length > 0) {
                    const defaultClip = object.animations[0];
                    const action = mixer.clipAction(defaultClip);
                    animations[defaultClip.name || 'default'] = action;
                    createAnimationButtons();
                    playAnimation(defaultClip.name || 'default');
                }
                 URL.revokeObjectURL(url);
            });
        }
        
        function prepareModelForToonShader(modelNode) {
            modelNode.traverse((child) => {
                if (child.isSkinnedMesh && child.material) {
                    child.userData.originalMaterial = child.material;
                    
                    const createToonMaterial = (originalMaterial) => new THREE.MeshToonMaterial({
                        color: originalMaterial.color,
                        map: originalMaterial.map,
                        gradientMap: toonGradientMap
                    });

                    if (Array.isArray(child.material)) {
                        child.userData.toonMaterial = child.material.map(createToonMaterial);
                    } else {
                        child.userData.toonMaterial = createToonMaterial(child.material);
                    }
                }
            });
        }
        
        // REWRITTEN with the correct API for OutlineEffect
        function setShader(modelNode, useToonShader) {
            if (!modelNode) return;

            modelNode.traverse((child) => {
                if (child.isSkinnedMesh && child.userData.originalMaterial) {
                    const targetMaterial = useToonShader ? child.userData.toonMaterial : child.userData.originalMaterial;
                    child.material = targetMaterial;

                    // This function adds or removes the outline parameters from a material
                    const applyOutline = (mat) => {
                        if (useToonShader) {
                            mat.userData.outlineParameters = {
                                thickness: 0.005,
                                color: [0, 0, 0], // Black outline
                                alpha: 1.0,
                                visible: true
                            };
                        } else {
                            // Deleting the property tells OutlineEffect to ignore it
                            delete mat.userData.outlineParameters;
                        }
                    };
                    
                    if (Array.isArray(child.material)) {
                        child.material.forEach(applyOutline);
                    } else {
                        applyOutline(child.material);
                    }
                }
            });
        }

        function loadAnimations(files) {
            for (const file of files) {
                const url = URL.createObjectURL(file);
                fbxLoader.load(url, (object) => {
                    const clip = object.animations[0];
                    if (clip && mixer) {
                        const animName = file.name.replace(/\.[^/.]+$/, "");
                        animations[animName] = mixer.clipAction(clip);
                    }
                    URL.revokeObjectURL(url); 
                    createAnimationButtons();
                }, undefined, (error) => {
                    console.error('An error happened while loading animation:', error);
                });
            }
        }

        function createAnimationButtons() {
            const buttonContainer = document.getElementById('animation-buttons');
            buttonContainer.innerHTML = '<p>Animations:</p>'; 

            Object.keys(animations).forEach(name => {
                const button = document.createElement('button');
                button.innerText = name;
                button.onclick = () => playAnimation(name);
                buttonContainer.appendChild(button);
            });
        }

        function playAnimation(name) {
            if (activeAction) activeAction.fadeOut(0.5);
            
            const newAction = animations[name];
            if (newAction) {
                newAction.reset().fadeIn(0.5).play();
                activeAction = newAction;

                const buttons = document.querySelectorAll('#animation-buttons button');
                buttons.forEach(btn => btn.classList.toggle('active', btn.innerText === name));
            }
        }

        // ## 5. Render Loop ##
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            controls.update();
            
            effect.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            effect.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>